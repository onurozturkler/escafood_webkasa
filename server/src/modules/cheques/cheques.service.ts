import { PrismaClient, ChequeStatus, ChequeDirection, DailyTransactionType, DailyTransactionSource } from '@prisma/client';
import { prisma } from '../../config/prisma';
import {
  CreateChequeDto,
  UpdateChequeDto,
  UpdateChequeStatusDto,
  ChequeListQuery,
  ChequeListResponse,
  ChequeDto,
  PayableChequeDto,
  PayChequeDto,
  PayChequeResponse,
} from './cheques.types';

/**
 * Get default status for a cheque based on direction
 */
function getDefaultStatus(direction: ChequeDirection): ChequeStatus {
  if (direction === 'ALACAK') {
    return 'KASADA';
  } else {
    return 'ODEMEDE';
  }
}

/**
 * Check if a status transition is allowed
 */
function isStatusTransitionAllowed(
  currentStatus: ChequeStatus,
  newStatus: ChequeStatus,
  direction: ChequeDirection
): boolean {
  // Any status can transition to KARSILIKSIZ
  if (newStatus === 'KARSILIKSIZ') {
    return true;
  }

  if (direction === 'ALACAK') {
    // For ALACAK cheques (customer cheques):
    // KASADA → BANKADA_TAHSILDE (sent to bank for collection)
    // KASADA → TAHSIL_EDILDI (collected directly into cash)
    // KASADA → ODEMEDE (used to pay a supplier - customer cheque given to supplier)
    // BANKADA_TAHSILDE → TAHSIL_EDILDI (collected from bank)
    const allowedTransitions: ChequeStatus[] = [];
    if (currentStatus === 'KASADA') {
      allowedTransitions.push('BANKADA_TAHSILDE', 'TAHSIL_EDILDI', 'ODEMEDE');
    } else if (currentStatus === 'BANKADA_TAHSILDE') {
      allowedTransitions.push('TAHSIL_EDILDI');
    }
    return allowedTransitions.includes(newStatus);
  } else {
    // For BORC cheques:
    // KASADA → ODENDI (paid directly from bank)
    // BANKADA_TAHSILDE → ODENDI (paid from bank)
    // ODEMEDE → ODENDI (paid)
    // TAHSIL_EDILDI → ODENDI (legacy: already collected, now paid)
    if (newStatus === 'ODENDI') {
      if (currentStatus === 'KASADA' || currentStatus === 'BANKADA_TAHSILDE' || currentStatus === 'ODEMEDE' || currentStatus === 'TAHSIL_EDILDI') {
        return true;
      }
    }
    return false;
  }
}

/**
 * Calculate cash balance after a transaction
 * FINANCIAL INVARIANT: Only KASA transactions affect cash balance
 * 
 * Gets all KASA transactions up to this date (excluding the one being created),
 * calculates balance, then adds the new transaction's incoming/outgoing if it's KASA
 */
async function calculateBalanceAfter(
  isoDate: string,
  incoming: number,
  outgoing: number,
  storedSource: string,
  excludeTransactionId?: string
): Promise<number> {
  // FINANCIAL INVARIANT: Only KASA transactions affect cash balance
  const where: any = {
    deletedAt: null,
    isoDate: { lte: isoDate },
    source: 'KASA', // Only include KASA transactions in cash balance calculation
  };

  if (excludeTransactionId) {
    where.id = { not: excludeTransactionId };
  }

  const transactions = await prisma.transaction.findMany({
    where,
    select: {
      incoming: true,
      outgoing: true,
    },
    orderBy: [
      { isoDate: 'asc' },
      { createdAt: 'asc' },
    ],
  });

  // Calculate balance up to this point (only KASA transactions)
  let balance = 0;
  for (const tx of transactions) {
    balance += Number(tx.incoming) - Number(tx.outgoing);
  }

  // Add the new transaction's effect only if it's a KASA transaction
  if (storedSource === 'KASA') {
    balance += incoming - outgoing;
  }

  return balance;
}

/**
 * Create a transaction for cheque collection/payment
 */
async function createChequeTransaction(
  chequeId: string,
  type: DailyTransactionType,
  source: DailyTransactionSource,
  isoDate: string,
  amount: number,
  counterparty: string | null,
  description: string | null,
  bankId: string | null,
  incoming: number,
  outgoing: number,
  bankDelta: number,
  displayIncoming: number | null,
  displayOutgoing: number | null,
  createdBy: string,
  createdByEmail: string
): Promise<string> {
  // FINANCIAL INVARIANT: Only KASA transactions affect cash balance
  const balanceAfter = await calculateBalanceAfter(isoDate, incoming, outgoing, source);

  // BELGE NO (ZORUNLU) - 3.1: Belge No asla boş olamaz
  // Çek işlemleri için otomatik belge no üret
  const { autoGenerateDocumentNo } = await import('../transactions/transactions.documentNo');
  const documentNo = await autoGenerateDocumentNo(
    type,
    source,
    isoDate,
    null // Always auto-generate for cheque transactions
  );

  const transaction = await prisma.transaction.create({
    data: {
      isoDate,
      documentNo: documentNo, // BELGE NO (ZORUNLU): Auto-generated
      type,
      source,
      counterparty,
      description,
      incoming: incoming,
      outgoing: outgoing,
      bankDelta: bankDelta,
      displayIncoming: displayIncoming,
      displayOutgoing: displayOutgoing,
      balanceAfter: balanceAfter,
      chequeId,
      bankId,
      createdBy, // KULLANICI / AUTH / AUDIT - 7.1: createdByUserId
      createdByEmail, // KULLANICI / AUTH / AUDIT - 7.1: createdByEmail
    },
  });

  return transaction.id;
}

export class ChequesService {
  /**
   * Create a new cheque
   * 
   * STANDARD CONTRACT:
   * - ALACAK (customer cheque): status = KASADA
   * - BORC (supplier cheque): status = ODEMEDE
   * - deletedAt = null (always)
   * - All required fields must be set (cekNo, amount, entryDate, maturityDate, direction)
   */
  async createCheque(data: CreateChequeDto, createdBy: string): Promise<ChequeDto> {
    try {
      console.log('[createCheque] Starting cheque creation', {
        cekNo: data.cekNo,
        direction: data.direction,
        createdBy,
      });
      
      const defaultStatus = getDefaultStatus(data.direction); // STANDARD CONTRACT: ALACAK → KASADA, BORC → ODEMEDE

      // ÇEK / SENET KANONİK SÖZLEŞMESİ - 9.1: Kasaya giren çek
      // Lehtar: Esca Food (ALACAK direction için, default: "Esca Food A.Ş.")
      // Düzenleyen: karşı taraf (customer.name veya free-text, zorunlu)
      // Çek Bankası (issuerBankName): Çeki düzenleyen banka adı (zorunlu, serbest metin)
      // Tahsile Verilen Banka (depositBankId): Çeki tahsile verdiğimiz banka (opsiyonel, sadece tahsile ver işleminde set edilir)
      // Müşteri/Tedarikçi sütunu: BOŞ (customerId = null, supplierId = null)
      
      // Set payeeName with default if not provided
      const payeeName = data.payeeName || 'Esca Food A.Ş.';
      console.log('[createCheque] Payee name:', payeeName);
    
    // Validate and set customerId, supplierId, depositBankId based on direction
    let customerId: string | null = null;
    let supplierId: string | null = null;
    let depositBankId: string | null = null;

    if (data.direction === 'ALACAK') {
      // ÇEK / SENET KANONİK SÖZLEŞMESİ - 9.1: Kasaya giren çek
      // Müşteri/Tedarikçi sütunu: BOŞ (customerId = null, supplierId = null)
      // depositBankId: Kasaya girişte null (sadece tahsile ver işleminde set edilir)
      customerId = null; // Always null for kasaya giren çek
      supplierId = null; // Always null for customer cheques
      depositBankId = null; // Always null for kasaya giren çek
    } else {
      // BORC (supplier cheque): set supplierId if provided and valid
      if (data.supplierId) {
        const supplier = await prisma.supplier.findUnique({
          where: { id: data.supplierId, deletedAt: null },
        });
        if (supplier) {
          supplierId = data.supplierId;
        }
        // If supplier doesn't exist, leave as null (no FK error)
      }
      customerId = null; // Always null for supplier cheques
      depositBankId = null; // Always null for kasaya giren çek
    }
    
    // Validate depositBankId if provided (only for deposit operations, not for entry)
    if (data.depositBankId) {
      const bank = await prisma.bank.findUnique({
        where: { id: data.depositBankId, deletedAt: null },
      });
      if (bank) {
        depositBankId = data.depositBankId;
      }
      // If bank doesn't exist, leave as null (no FK error)
    }

    // MVP: Create attachment from imageDataUrl if provided
    let attachmentId: string | null = data.attachmentId || null;
    if (data.imageDataUrl && !attachmentId) {
      try {
        // Create attachment record for the image
        // Extract base64 data (remove data:image/jpeg;base64, prefix if present)
        const base64Data = data.imageDataUrl.includes(',') 
          ? data.imageDataUrl.split(',')[1] 
          : data.imageDataUrl;
        
        const attachment = await prisma.attachment.create({
          data: {
            fileName: `cheque-${data.cekNo}-${Date.now()}.jpg`,
            mimeType: 'image/jpeg', // Default, could be detected from data URL
            base64Data: base64Data,
            createdBy: createdBy, // createdBy is required (not null), but relation is optional
          },
        });
        attachmentId = attachment.id;
      } catch (attachmentError) {
        console.error('Failed to create attachment:', attachmentError);
        // If attachment creation fails, continue without it (imageDataUrl will be stored directly)
        // This is MVP behavior - attachment creation is optional
        attachmentId = null;
      }
    }

    const cheque = await prisma.cheque.create({
      data: {
        cekNo: data.cekNo,
        amount: data.amount,
        entryDate: data.entryDate,
        maturityDate: data.maturityDate,
        status: defaultStatus,
        direction: data.direction,
        drawerName: data.drawerName,
        payeeName: payeeName,
        issuerBankName: data.issuerBankName, // Çeki düzenleyen banka adı (zorunlu)
        depositBankId: depositBankId, // Çeki tahsile verdiğimiz banka (opsiyonel)
        customerId,
        supplierId,
        description: data.description || null,
        attachmentId: attachmentId,
        imageDataUrl: data.imageDataUrl || null, // MVP: Store temporarily until Attachment is fully used
        createdBy,
      },
      include: {
        depositBank: {
          select: {
            id: true,
            name: true,
            accountNo: true,
            iban: true,
          },
        },
        customer: {
          select: {
            id: true,
            name: true,
          },
        },
        supplier: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

      console.log('[createCheque] Cheque created successfully:', cheque.id);
      const result = this.mapToDto(cheque);
      console.log('[createCheque] Returning mapped DTO');
      return result;
    } catch (error) {
      console.error('[createCheque] Error in createCheque service:', error);
      console.error('[createCheque] Error type:', typeof error);
      console.error('[createCheque] Error constructor:', error?.constructor?.name);
      if (error instanceof Error) {
        console.error('[createCheque] Error message:', error.message);
        console.error('[createCheque] Error stack:', error.stack);
      }
      // Re-throw to let controller handle it
      throw error;
    }
  }

  /**
   * Update a cheque (base fields only, no status change)
   */
  async updateCheque(id: string, data: UpdateChequeDto, updatedBy: string): Promise<ChequeDto> {
    const cheque = await prisma.cheque.findUnique({
      where: { id },
    });

    if (!cheque) {
      throw new Error('Cheque not found');
    }

    if (cheque.deletedAt) {
      throw new Error('Cannot update deleted cheque');
    }

    // Validate and set customerId, supplierId, bankId if provided
    const updateData: any = {
      ...data,
      updatedBy,
      updatedAt: new Date(),
    };

    // Validate customerId if provided
    if (data.customerId !== undefined) {
      if (data.customerId) {
        const customer = await prisma.customer.findUnique({
          where: { id: data.customerId, deletedAt: null },
        });
        updateData.customerId = customer ? data.customerId : null;
      } else {
        updateData.customerId = null;
      }
    }

    // Validate supplierId if provided
    if (data.supplierId !== undefined) {
      if (data.supplierId) {
        const supplier = await prisma.supplier.findUnique({
          where: { id: data.supplierId, deletedAt: null },
        });
        updateData.supplierId = supplier ? data.supplierId : null;
      } else {
        updateData.supplierId = null;
      }
    }

    // Validate depositBankId if provided
    if (data.depositBankId !== undefined) {
      if (data.depositBankId) {
        const bank = await prisma.bank.findUnique({
          where: { id: data.depositBankId, deletedAt: null },
        });
        updateData.depositBankId = bank ? data.depositBankId : null;
      } else {
        updateData.depositBankId = null;
      }
    }

    const updated = await prisma.cheque.update({
      where: { id },
      data: updateData,
      include: {
        depositBank: {
          select: {
            id: true,
            name: true,
            accountNo: true,
            iban: true,
          },
        },
        customer: {
          select: {
            id: true,
            name: true,
          },
        },
        supplier: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    return this.mapToDto(updated);
  }

  /**
   * Update cheque status with transaction side-effects
   */
  async updateChequeStatus(
    id: string,
    data: UpdateChequeStatusDto,
    updatedBy: string,
    createdByEmail: string
  ): Promise<{ cheque: ChequeDto; transactionId: string | null }> {
    const cheque = await prisma.cheque.findUnique({
      where: { id },
      include: {
        customer: true,
        supplier: true,
        depositBank: true,
      },
    });

    if (!cheque) {
      throw new Error('Cheque not found');
    }

    if (cheque.deletedAt) {
      throw new Error('Cannot update deleted cheque');
    }

    // Validate status transition
    if (!isStatusTransitionAllowed(cheque.status, data.newStatus, cheque.direction)) {
      throw new Error(
        `Invalid status transition from ${cheque.status} to ${data.newStatus} for direction ${cheque.direction}`
      );
    }

    let transactionId: string | null = null;

    // Handle transaction side-effects based on status change
    if (data.newStatus === 'TAHSIL_EDILDI') {
      if (cheque.direction === 'ALACAK') {
        // Customer cheque collected
        const amount = Number(cheque.amount);
        // CRITICAL: Muhatap = çeki düzenleyen (drawerName)
        const counterparty = cheque.drawerName || cheque.customer?.name || null;
        const description = data.description || `Çek No: ${cheque.cekNo}`;

        if (data.depositBankId) {
          // Collected into BANK
          transactionId = await createChequeTransaction(
            cheque.id,
            'CEK_TAHSIL_BANKA',
            'BANKA',
            data.isoDate,
            amount,
            counterparty,
            description,
            data.depositBankId,
            0, // incoming
            0, // outgoing
            amount, // bankDelta positive
            null, // displayIncoming
            null, // displayOutgoing
            updatedBy,
            createdByEmail
          );
        } else {
          // Collected into CASH
          transactionId = await createChequeTransaction(
            cheque.id,
            'CEK_TAHSIL_BANKA',
            'KASA',
            data.isoDate,
            amount,
            counterparty,
            description,
            null, // bankId
            amount, // incoming
            0, // outgoing
            0, // bankDelta
            null, // displayIncoming
            null, // displayOutgoing
            updatedBy,
            createdByEmail
          );
        }
      } else {
        // BORC cheque paid
        const amount = Number(cheque.amount);
        // CRITICAL: Muhatap = çeki düzenleyen (drawerName)
        const counterparty = cheque.drawerName || cheque.supplier?.name || null;
        const description = data.description || `Çek No: ${cheque.cekNo}`;

        if (data.depositBankId) {
          // Paid from BANK
          transactionId = await createChequeTransaction(
            cheque.id,
            'CEK_ODENMESI',
            'BANKA',
            data.isoDate,
            amount,
            counterparty,
            description,
            data.depositBankId,
            0, // incoming
            0, // outgoing
            -amount, // bankDelta negative
            null, // displayIncoming
            null, // displayOutgoing
            updatedBy,
            createdByEmail
          );
        } else {
          // Paid from CASH
          transactionId = await createChequeTransaction(
            cheque.id,
            'CEK_ODENMESI',
            'KASA',
            data.isoDate,
            amount,
            counterparty,
            description,
            null, // bankId
            0, // incoming
            amount, // outgoing
            0, // bankDelta
            null, // displayIncoming
            null, // displayOutgoing
            updatedBy,
            createdByEmail
          );
        }
      }
    } else if (data.newStatus === 'KARSILIKSIZ') {
      // Optional info-only row for bounced cheque
      const amount = Number(cheque.amount);
      // CRITICAL: Muhatap = çeki düzenleyen (drawerName)
      const counterparty = cheque.drawerName || (cheque.direction === 'ALACAK' ? cheque.customer?.name : cheque.supplier?.name) || null;
      const description = data.description || `Çek No: ${cheque.cekNo} - Karşılıksız`;

      transactionId = await createChequeTransaction(
        cheque.id,
        'CEK_KARSILIKSIZ',
        'CEK',
        data.isoDate,
        amount,
        counterparty,
        description,
        null, // bankId
        0, // incoming
        0, // outgoing
        0, // bankDelta
        null, // displayIncoming
        amount, // displayOutgoing (optional info)
        updatedBy,
        createdByEmail
      );
    }

    // ÇEK / SENET KANONİK SÖZLEŞMESİ - 9.2: Kasadan tedarikçiye verilen çek
    // Müşteri/Tedarikçi sütunu: ilgili tedarikçi adı (supplier.name)
    // Düzenleyen ile ASLA aynı yazılamaz
    // BUG 7 FIX: When cheque goes to ODEMEDE (given to supplier), set supplierId
    // Note: Transaction is already created by frontend (bank cash out), so we don't create another one
    // Use explicit control flow instead of nested ternaries for clarity
    let supplierIdToSet: string | null | undefined = undefined; // undefined = don't update, null = set to null, string = set to value
    
    if (data.newStatus === 'ODEMEDE' && cheque.direction === 'ALACAK') {
      // Customer cheque given to supplier - validate and set supplierId
      if (data.supplierId) {
        const supplier = await prisma.supplier.findUnique({
          where: { id: data.supplierId, deletedAt: null },
        });
        if (supplier) {
          supplierIdToSet = data.supplierId; // Set to new supplier ID
          // BUG 7 FIX: Don't create transaction here - frontend already created it via bank cash out
          // Transaction is linked via chequeId in the transaction record
          // Just update the cheque status and supplierId (done below)
        } else {
          // Supplier not found - keep existing supplierId (don't update)
          supplierIdToSet = undefined;
        }
      } else {
        // No supplierId provided - keep existing supplierId (don't update)
        supplierIdToSet = undefined;
      }
    } else {
      // Not ODEMEDE status or not ALACAK direction - don't update supplierId
      supplierIdToSet = undefined;
    }
    
    // ÇEK / SENET KANONİK SÖZLEŞMESİ - 9.3: Bankaya tahsile verilen çek
    // Statü: BANKADA_TAHSILDE
    // Tahsile Verilen Banka (depositBankId) görünür
    // Açıklamaya: "Bankaya tahsile verildi – {Banka Adı}" eklenir
    let depositBankIdToSet: string | null = null;
    let descriptionToSet: string | null = null;
    
    if (data.newStatus === 'BANKADA_TAHSILDE') {
      if (!data.depositBankId) {
        throw new Error('Bankaya tahsile verilen çek için banka seçilmelidir');
      }
      
      const bank = await prisma.bank.findUnique({
        where: { id: data.depositBankId, deletedAt: null },
      });
      
      if (!bank) {
        throw new Error('Seçilen banka bulunamadı');
      }
      
      depositBankIdToSet = data.depositBankId;
      
      // ÇEK / SENET KANONİK SÖZLEŞMESİ - 9.4: Açıklama güncelleme kuralı
      // Yeni işlemde açıklama girildiyse → overwrite
      // Boş bırakıldıysa → eski açıklama korunur
      const bankNote = `Bankaya tahsile verildi – ${bank.name}`;
      if (data.description && data.description.trim()) {
        // Yeni açıklama varsa, banka notunu ekle
        descriptionToSet = `${data.description.trim()} | ${bankNote}`;
      } else {
        // Boş bırakıldıysa, eski açıklamaya banka notunu ekle
        const existingDesc = cheque.description || '';
        descriptionToSet = existingDesc ? `${existingDesc} | ${bankNote}` : bankNote;
      }
    } else {
      // ÇEK / SENET KANONİK SÖZLEŞMESİ - 9.4: Açıklama güncelleme kuralı
      // Yeni işlemde açıklama girildiyse → overwrite
      // Boş bırakıldıysa → eski açıklama korunur
      if (data.description !== undefined) {
        if (data.description && data.description.trim()) {
          // Yeni açıklama varsa, overwrite
          descriptionToSet = data.description.trim();
        } else {
          // Boş bırakıldıysa, eski açıklama korunur
          descriptionToSet = cheque.description;
        }
      } else {
        // Açıklama gönderilmediyse, eski açıklama korunur
        descriptionToSet = cheque.description;
      }
    }
    
    // Build update data - only include supplierId if we want to change it
    const updateData: any = {
      status: data.newStatus,
      depositBankId: depositBankIdToSet,
      updatedBy,
      updatedAt: new Date(),
    };
    
    // Only include supplierId in update if we explicitly want to change it
    if (supplierIdToSet !== undefined) {
      updateData.supplierId = supplierIdToSet;
    }
    
    // Include description if we have a new value
    if (descriptionToSet !== null) {
      updateData.description = descriptionToSet;
    }
    
    // Update cheque status and supplierId if applicable
    const updated = await prisma.cheque.update({
      where: { id },
      data: updateData,
      include: {
        depositBank: {
          select: {
            id: true,
            name: true,
            accountNo: true,
            iban: true,
          },
        },
        customer: {
          select: {
            id: true,
            name: true,
          },
        },
        supplier: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    return {
      cheque: this.mapToDto(updated),
      transactionId,
    };
  }

  /**
   * Get cheque by ID
   */
  async getChequeById(id: string): Promise<ChequeDto | null> {
    const cheque = await prisma.cheque.findUnique({
      where: { id },
      include: {
        depositBank: {
          select: {
            id: true,
            name: true,
            accountNo: true,
            iban: true,
          },
        },
        customer: {
          select: {
            id: true,
            name: true,
          },
        },
        supplier: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    if (!cheque || cheque.deletedAt) {
      return null;
    }

    return this.mapToDto(cheque);
  }

  /**
   * List cheques with filters
   */
  async listCheques(query: ChequeListQuery): Promise<ChequeListResponse> {
    const where: any = {
      deletedAt: null,
    };

    // FIX: Support status filter - if status is provided, use it; if "ALL", show all (no filter)
    if (query.status !== undefined) {
      where.status = query.status;
    }

    if (query.direction) {
      where.direction = query.direction;
    }

    if (query.entryFrom || query.entryTo) {
      where.entryDate = {};
      if (query.entryFrom) {
        where.entryDate.gte = query.entryFrom;
      }
      if (query.entryTo) {
        where.entryDate.lte = query.entryTo;
      }
    }

    if (query.maturityFrom || query.maturityTo) {
      where.maturityDate = {};
      if (query.maturityFrom) {
        where.maturityDate.gte = query.maturityFrom;
      }
      if (query.maturityTo) {
        where.maturityDate.lte = query.maturityTo;
      }
    }

    if (query.customerId) {
      where.customerId = query.customerId;
    }

    if (query.supplierId) {
      where.supplierId = query.supplierId;
    }

    if (query.bankId) {
      // Legacy support: bankId query param maps to depositBankId
      where.depositBankId = query.bankId;
    }

    if (query.search) {
      where.OR = [
        { cekNo: { contains: query.search, mode: 'insensitive' } },
        { description: { contains: query.search, mode: 'insensitive' } },
      ];
    }

    const page = query.page || 1;
    const pageSize = query.pageSize || 50;
    const skip = (page - 1) * pageSize;

    const [cheques, totalCount] = await Promise.all([
      prisma.cheque.findMany({
        where,
        skip,
        take: pageSize,
        orderBy: [
          { maturityDate: 'asc' },
          { entryDate: 'asc' },
        ],
        include: {
          depositBank: {
            select: {
              id: true,
              name: true,
              accountNo: true,
              iban: true,
            },
          },
          customer: {
            select: {
              id: true,
              name: true,
            },
          },
          supplier: {
            select: {
              id: true,
              name: true,
            },
          },
        },
      }),
      prisma.cheque.count({ where }),
    ]);

    const totalAmount = cheques.reduce((sum: number, c) => sum + Number(c.amount), 0);

    // Calculate upcoming maturities
    const today = new Date().toISOString().split('T')[0];
    const sevenDaysLater = new Date();
    sevenDaysLater.setDate(sevenDaysLater.getDate() + 7);
    const sevenDaysLaterStr = sevenDaysLater.toISOString().split('T')[0];
    const thirtyDaysLater = new Date();
    thirtyDaysLater.setDate(thirtyDaysLater.getDate() + 30);
    const thirtyDaysLaterStr = thirtyDaysLater.toISOString().split('T')[0];

    const allCheques = await prisma.cheque.findMany({
      where: {
        ...where,
        status: {
          in: ['KASADA', 'BANKADA_TAHSILDE', 'ODEMEDE'],
        },
      },
    });

    const within7Days = allCheques.filter(
      (c) => c.maturityDate >= today && c.maturityDate <= sevenDaysLaterStr
    ).length;
    const within30Days = allCheques.filter(
      (c) => c.maturityDate >= today && c.maturityDate <= thirtyDaysLaterStr
    ).length;
    const overdue = allCheques.filter((c) => c.maturityDate < today).length;

    return {
      items: cheques.map((c) => this.mapToDto(c)),
      totalCount,
      totalAmount,
      upcomingMaturities: {
        within7Days,
        within30Days,
        overdue,
      },
    };
  }

  /**
   * Map Prisma cheque to DTO
   */
  private mapToDto(cheque: any): ChequeDto {
    return {
      id: cheque.id,
      cekNo: cheque.cekNo,
      amount: Number(cheque.amount),
      entryDate: cheque.entryDate,
      maturityDate: cheque.maturityDate,
      status: cheque.status,
      direction: cheque.direction,
      customerId: cheque.customerId,
      supplierId: cheque.supplierId,
      issuerBankName: cheque.issuerBankName, // Çeki düzenleyen banka adı
      depositBankId: cheque.depositBankId, // Çeki tahsile verdiğimiz banka
      drawerName: cheque.drawerName,
      payeeName: cheque.payeeName,
      description: cheque.description,
      attachmentId: cheque.attachmentId,
      imageDataUrl: cheque.imageDataUrl,
      createdAt: cheque.createdAt.toISOString(),
      createdBy: cheque.createdBy,
      updatedAt: cheque.updatedAt?.toISOString() || null,
      updatedBy: cheque.updatedBy || null,
      deletedAt: cheque.deletedAt?.toISOString() || null,
      deletedBy: cheque.deletedBy || null,
      depositBank: cheque.depositBank || null, // Çeki tahsile verdiğimiz banka (bizim bankamız)
      customer: cheque.customer || null,
      supplier: cheque.supplier || null,
    };
  }

  /**
   * Get payable cheques (BORC direction, not paid yet)
   * Used for bank cash out cheque payment dropdown
   * 
   * STANDARD FILTER CONTRACT:
   * - deletedAt = null (active only)
   * - direction = BORC (we pay them)
   * - status != ODENDI (not paid yet)
   * - maturityDate >= todayStart (upcoming or today)
   */
  async getPayableCheques(bankId?: string | null): Promise<PayableChequeDto[]> {
    // Calculate todayStart (Date object, normalized to start of day)
    const todayStart = new Date();
    todayStart.setHours(0, 0, 0, 0);
    const todayStartIso = todayStart.toISOString().split('T')[0];
    
    const where: any = {
      deletedAt: null, // Active cheques only
      direction: 'BORC', // Only BORC cheques (we pay them)
      status: { not: 'ODENDI' }, // Not paid yet
      maturityDate: { gte: todayStartIso }, // Upcoming or today (STANDARD CONTRACT)
    };

    // SINGLE SOURCE OF TRUTH FIX: Filter by depositBankId if provided
    // This ensures only cheques for the selected bank are shown in dropdown
    if (bankId) {
      where.depositBankId = bankId;
    }

    const cheques = await prisma.cheque.findMany({
      where,
      include: {
        supplier: {
          select: {
            id: true,
            name: true,
          },
        },
        customer: {
          select: {
            id: true,
            name: true,
          },
        },
        depositBank: {
          select: {
            id: true,
            name: true,
          },
        },
      },
      orderBy: [
        { maturityDate: 'asc' },
        { createdAt: 'asc' },
      ],
      take: 200,
    });

    return cheques.map((cheque) => ({
      id: cheque.id,
      cekNo: cheque.cekNo,
      maturityDate: cheque.maturityDate,
      amount: cheque.amount.toNumber(),
      counterparty: cheque.supplier?.name || cheque.customer?.name || `Çek ${cheque.cekNo}`,
      bankId: cheque.depositBankId,
    }));
  }

  /**
   * Pay a cheque from bank (atomic transaction)
   * Creates transaction and updates cheque status in a single DB transaction
   */
  async payCheque(chequeId: string, data: PayChequeDto, createdBy: string, createdByEmail: string): Promise<PayChequeResponse> {
    return await prisma.$transaction(async (tx) => {
      // 1. Find and validate cheque
      const cheque = await tx.cheque.findUnique({
        where: { id: chequeId },
        include: {
          supplier: {
            select: {
              id: true,
              name: true,
            },
          },
          customer: {
            select: {
              id: true,
              name: true,
            },
          },
        },
      });

      if (!cheque) {
        throw new Error('Çek bulunamadı');
      }

      if (cheque.deletedAt) {
        throw new Error('Silinmiş çek ödenemez');
      }

      if (cheque.direction !== 'BORC') {
        throw new Error('Sadece BORC çekler ödenebilir');
      }

      if (cheque.status === 'ODENDI') {
        throw new Error('Bu çek zaten ödenmiş');
      }

      // 2. Generate document number (BNK-CKS format: BNK-CKS-DD/MM-XXXX)
      const [year, month, day] = data.paymentDate.split('-');
      const gg = (day ?? '01').padStart(2, '0');
      const aa = (month ?? '01').padStart(2, '0');
      const prefix = `BNK-CKS-${gg}/${aa}-`;
      
      // Find existing transactions with same prefix on the same date
      const existingTransactions = await tx.transaction.findMany({
        where: {
          deletedAt: null,
          isoDate: data.paymentDate,
          documentNo: { startsWith: prefix },
        },
        select: { documentNo: true },
      });
      
      // Find max sequence number
      const maxSeq = existingTransactions.reduce((max, tx) => {
        if (!tx.documentNo || !tx.documentNo.startsWith(prefix)) return max;
        const suffix = tx.documentNo.slice(prefix.length);
        const n = parseInt(suffix, 10);
        return Number.isNaN(n) ? max : Math.max(max, n);
      }, 0);
      
      // Generate next document number
      const nextSeq = String(maxSeq + 1).padStart(4, '0');
      const documentNo = `${prefix}${nextSeq}`;

      // 3. Create transaction
      const amount = cheque.amount.toNumber();
      const counterparty = cheque.supplier?.name || cheque.customer?.name || `Çek ${cheque.cekNo}`;
      // Include supplier name in description if available
      const supplierName = cheque.supplier?.name ? ` - ${cheque.supplier.name}` : '';
      const description = data.note || `Çek No: ${cheque.cekNo}${supplierName}`;

      // FINANCIAL INVARIANT: Bank cash out - only affects bank balance, not cash
      const balanceAfter = await calculateBalanceAfter(data.paymentDate, 0, 0, 'BANKA');

      const transaction = await tx.transaction.create({
        data: {
          isoDate: data.paymentDate,
          documentNo, // Generated document number
          type: 'CEK_ODENMESI',
          source: 'BANKA',
          counterparty,
          description,
          incoming: 0,
          outgoing: 0, // Bank cash out doesn't affect cash balance
          bankDelta: -amount, // Negative: bank balance decreases
          displayIncoming: null,
          displayOutgoing: amount, // Show amount in UI
          balanceAfter,
          bankId: data.bankId,
          chequeId: chequeId,
          createdBy, // KULLANICI / AUTH / AUDIT - 7.1: createdByUserId
          createdByEmail, // KULLANICI / AUTH / AUDIT - 7.1: createdByEmail
        },
      });

      // 3. Update cheque status to ODENDI with payment details
      // STANDARD CONTRACT: Cheque payment sets status=ODENDI, paidAt, paidBankId, paymentTransactionId
      // deletedAt is NEVER set (soft delete is not used for paid cheques)
      const paymentDate = new Date(data.paymentDate + 'T00:00:00Z');
      const updatedCheque = await tx.cheque.update({
        where: { id: chequeId },
        data: {
          status: 'ODENDI', // STANDARD CONTRACT: Paid cheques have status=ODENDI
          paidAt: paymentDate,
          paidBankId: data.bankId,
          paymentTransactionId: transaction.id,
          updatedAt: new Date(),
          updatedBy: createdBy,
          // CRITICAL: deletedAt is NOT set - paid cheques remain visible in reports
        },
        select: {
          id: true,
          status: true,
          paidAt: true,
          paidBankId: true,
          paymentTransactionId: true,
        },
      });

      return {
        ok: true,
        paidChequeId: chequeId,
        transactionId: transaction.id,
        updatedCheque: {
          id: updatedCheque.id,
          status: updatedCheque.status,
          paidAt: updatedCheque.paidAt?.toISOString() || null,
          paidBankId: updatedCheque.paidBankId,
          paymentTransactionId: updatedCheque.paymentTransactionId,
        },
      };
    });
  }
}

