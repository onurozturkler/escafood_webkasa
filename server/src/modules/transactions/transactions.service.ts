import { PrismaClient } from '@prisma/client';
import { prisma } from '../../config/prisma';
import {
  CreateTransactionDto,
  UpdateTransactionDto,
  TransactionListQuery,
  TransactionListResponse,
  TransactionDto,
} from './transactions.types';
import { normalizeTransactionPayload } from './transactions.normalization';
import { autoGenerateDocumentNo, generateTransferDocumentNo } from './transactions.documentNo';

/**
 * Calculate cash balance after a transaction
 * 
 * Refactored to be more robust:
 * - Accepts cashAccountId (optional) for future multi-account support
 * - Uses storedSource from transaction records (not client-provided source)
 * - Computes balance using aggregate or ordered findMany
 * - Handles exclusion of current transaction for updates
 * 
 * Rules:
 * - Only transactions with source = KASA affect cash balance
 * - Bank transactions (source = BANKA) do NOT affect cash balance
 * - Balance = Σ(incoming - outgoing) for all KASA transactions up to isoDate (inclusive)
 * - Transactions are ordered by isoDate (asc), then createdAt (asc) for consistency
 * 
 * @param isoDate - Date up to which to calculate balance (inclusive)
 * @param incoming - Incoming amount for current transaction
 * @param outgoing - Outgoing amount for current transaction
 * @param storedSource - Source stored in DB (KASA or BANKA)
 * @param excludeTransactionId - Optional transaction ID to exclude from calculation
 * @param cashAccountId - Optional cash account ID (for future multi-account support)
 * @returns Calculated cash balance after the transaction
 */
async function calculateBalanceAfter(
  isoDate: string,
  incoming: number,
  outgoing: number,
  storedSource: string,
  excludeTransactionId?: string,
  cashAccountId?: string | null
): Promise<number> {
  // Build where clause: only KASA transactions affect cash balance
  const where: any = {
    deletedAt: null,
    isoDate: { lte: isoDate },
    source: 'KASA', // Only include KASA transactions in cash balance calculation
  };

  // Exclude specific transaction (for updates)
  if (excludeTransactionId) {
    where.id = { not: excludeTransactionId };
  }

  // Future: filter by cashAccountId if provided
  if (cashAccountId) {
    where.cashAccountId = cashAccountId;
  }

  // Use aggregate for better performance on large datasets
  // But we need chronological order, so use findMany with ordering
  const transactions = await prisma.transaction.findMany({
    where,
    select: {
      incoming: true,
      outgoing: true,
    },
    orderBy: [
      { isoDate: 'asc' },
      { createdAt: 'asc' },
    ],
  });

  // Calculate running balance: sum of (incoming - outgoing) for all transactions
  let balance = 0;
  for (const tx of transactions) {
    const cashDelta = Number(tx.incoming) - Number(tx.outgoing);
    balance += cashDelta;
  }

  // Add current transaction if it's a KASA transaction
  if (storedSource === 'KASA') {
    const cashDelta = incoming - outgoing;
    balance += cashDelta;
  }

  return balance;
}

export class TransactionsService {
  /**
   * Create a new transaction
   * 
   * STRICT TRANSACTION MAPPING:
   * 1) CASH IN (NAKIT_TAHSILAT, source=KASA): incoming=amount, outgoing=0, bankDelta=0
   * 2) CASH OUT (NAKIT_ODEME, source=KASA): incoming=0, outgoing=amount, bankDelta=0
   * 3) BANK CASH IN (NAKIT_TAHSILAT, source=BANKA): incoming=0, outgoing=0, bankDelta=+amount
   * 4) BANK CASH OUT (NAKIT_ODEME, source=BANKA): incoming=0, outgoing=amount, bankDelta=-amount
   * 5) POS COLLECTION (POS_TAHSILAT_BRUT): incoming=0, outgoing=0, bankDelta=+netAmount
   * 6) CREDIT CARD EXPENSE: incoming=0, outgoing=0, bankDelta=0 (cardDebtDelta handled separately)
   * 7) CREDIT CARD PAYMENT: source=BANKA, outgoing=amount, bankDelta=-amount
   * 
   * DOUBLE-ENTRY TRANSFERS:
   * 8) BANKA_KASA_TRANSFER: Creates 2 transactions:
   *    - Bank row (source=BANKA, bankDelta=-amount, incoming=0, outgoing=0)
   *    - Cash row (source=KASA, incoming=amount, outgoing=0, bankDelta=0)
   * 9) KASA_BANKA_TRANSFER: Creates 2 transactions:
   *    - Cash row (source=KASA, outgoing=amount, incoming=0, bankDelta=0)
   *    - Bank row (source=BANKA, bankDelta=+amount, incoming=0, outgoing=0)
   */
  async createTransaction(data: CreateTransactionDto, createdBy: string, createdByEmail: string): Promise<TransactionDto> {
    // Handle double-entry transfers
    // TÜR / AÇIKLAMA / KATEGORİ AYRIMI - 4.1: Tür, satırın perspektifini anlatmalı
    // Aynı tür adı banka ve kasada kullanılamaz
    // Örn: BANKA_KASA_TRANSFER_OUT, BANKA_KASA_TRANSFER_IN
    const isTransferType = 
      data.type === 'BANKA_KASA_TRANSFER_OUT' || 
      data.type === 'BANKA_KASA_TRANSFER_IN' ||
      data.type === 'KASA_BANKA_TRANSFER_OUT' ||
      data.type === 'KASA_BANKA_TRANSFER_IN';
    
    if (isTransferType) {
      return this.createTransferTransaction(data, createdBy, createdByEmail);
    }
    // Normalize transaction payload to canonical form
    const normalized = normalizeTransactionPayload(data);
    const { incoming, outgoing, bankDelta, storedSource } = normalized;

    // Calculate balance after using normalized amounts and stored source
    const balanceAfter = await calculateBalanceAfter(
      data.isoDate,
      incoming,
      outgoing,
      storedSource,
      undefined, // No exclusion for new transactions
      data.cashAccountId ?? null
    );

    // Data has already been validated by Zod schema, so bankId and creditCardId are either
    // valid UUID strings or null. We just need to ensure they're properly typed.
    const bankId: string | null = data.bankId && typeof data.bankId === 'string' ? data.bankId : null;
    const creditCardId: string | null = data.creditCardId && typeof data.creditCardId === 'string' ? data.creditCardId : null;

    // If bankId is provided, verify the bank exists (defensive check)
    if (bankId) {
      const bank = await prisma.bank.findUnique({
        where: { id: bankId },
        select: { id: true, name: true, deletedAt: true },
      });
      if (!bank) {
        // Log available banks for debugging
        const allBanks = await prisma.bank.findMany({
          where: { deletedAt: null },
          select: { id: true, name: true },
          take: 10,
        });
        console.error(`Bank with ID ${bankId} not found. Available banks:`, allBanks.map(b => ({ id: b.id, name: b.name })));
        
        // Create a custom error that can be identified as a client error (400)
        const error = new Error(`Bank with ID ${bankId} not found. Please select a valid bank.`);
        (error as any).statusCode = 400;
        (error as any).isClientError = true;
        throw error;
      }
      if (bank.deletedAt) {
        const error = new Error(`Bank "${bank.name}" (ID: ${bankId}) has been deleted`);
        (error as any).statusCode = 400;
        (error as any).isClientError = true;
        throw error;
      }
      console.log(`Bank verified: ${bank.name} (${bank.id})`);
    }

    // DEBUG: Log POS transactions to verify bankDelta and bankId
    if (data.type === 'POS_TAHSILAT_BRUT' || data.type === 'POS_KOMISYONU') {
      console.log('[POS DEBUG] Creating POS transaction:', {
        type: data.type,
        bankId: bankId,
        providedBankDelta: data.bankDelta,
        normalizedBankDelta: bankDelta,
        displayIncoming: data.displayIncoming,
        displayOutgoing: data.displayOutgoing,
      });
    }
    
    // BELGE NO (ZORUNLU) - 3.1: Belge No asla boş olamaz
    // Backend: Create sırasında belgeNo yoksa otomatik üretir
    const documentNo = await autoGenerateDocumentNo(
      data.type,
      storedSource,
      data.isoDate,
      data.documentNo
    );

    // Log for debugging - detailed logging with normalized values
    console.log('=== CREATE TRANSACTION SERVICE ===');
    console.log('Input data:', JSON.stringify(data, null, 2));
    console.log('Normalized amounts:', { incoming, outgoing, bankDelta, storedSource });
    console.log('bankId:', bankId);
    console.log('creditCardId:', creditCardId);
    console.log('Balance after:', balanceAfter);
    console.log('Document No (auto-generated):', documentNo);
    console.log('Created by:', createdBy);
    
    // Prepare Prisma data - ensure all FKs are either valid UUID strings or null
    // Data has already been validated by Zod, so we can trust the types
    // NOTE: attachmentId must be uploaded via /api/attachments first
    const prismaData = {
      isoDate: data.isoDate,
      documentNo: documentNo, // BELGE NO (ZORUNLU): Always set (auto-generated if not provided)
      type: data.type,
      source: storedSource, // Use normalized stored source
      counterparty: data.counterparty ?? null,
      description: data.description ?? null,
      category: data.category ?? null,
      incoming: incoming, // Use normalized incoming
      outgoing: outgoing, // Use normalized outgoing
      bankDelta: bankDelta, // Use normalized bankDelta
      displayIncoming: data.displayIncoming ?? null,
      displayOutgoing: data.displayOutgoing ?? null,
      balanceAfter: balanceAfter,
      cashAccountId: data.cashAccountId ?? null,
      bankId: bankId, // Already validated as UUID string or null by Zod
      creditCardId: creditCardId, // Already validated as UUID string or null by Zod
      chequeId: data.chequeId ?? null,
      customerId: data.customerId ?? null,
      supplierId: data.supplierId ?? null,
      attachmentId: data.attachmentId ?? null, // Attachment must be uploaded via /api/attachments first
      loanInstallmentId: data.loanInstallmentId ?? null,
      createdBy, // KULLANICI / AUTH / AUDIT - 7.1: createdByUserId
      createdByEmail, // KULLANICI / AUTH / AUDIT - 7.1: createdByEmail (denormalized for performance)
    };

    console.log('Prisma create data (normalized):', JSON.stringify(prismaData, null, 2));

    try {
      const transaction = await prisma.transaction.create({
        data: prismaData,
      });

      // DEBUG: Log created transaction with attachmentId
      console.log('[TransactionsService] Transaction created:', {
        id: transaction.id,
        type: transaction.type,
        attachmentId: transaction.attachmentId,
        documentNo: transaction.documentNo,
        bankId: transaction.bankId,
      });
      
      // DEBUG: Log created POS transaction from DB
      if (transaction.type === 'POS_TAHSILAT_BRUT' || transaction.type === 'POS_KOMISYONU') {
        console.log('[POS DEBUG] Transaction created in DB:', {
          id: transaction.id,
          type: transaction.type,
          bankId: transaction.bankId,
          bankDelta: transaction.bankDelta?.toNumber(),
          documentNo: transaction.documentNo,
          attachmentId: transaction.attachmentId,
        });
      }

      console.log('Transaction created successfully:', transaction.id);
      return this.mapToDto(transaction);
    } catch (error: any) {
      // Handle Prisma foreign key constraint errors
      if (error?.code === 'P2003') {
        const field = error.meta?.field_name || 'foreign key';
        const target = error.meta?.target || 'unknown';
        console.error('=== FOREIGN KEY CONSTRAINT VIOLATION ===');
        console.error('Field:', field);
        console.error('Target:', target);
        console.error('Full error:', JSON.stringify(error.meta, null, 2));
        console.error('Prisma data that failed:', JSON.stringify(prismaData, null, 2));
        throw new Error(`Invalid ${field} (${target}): The referenced record does not exist. bankId=${prismaData.bankId}`);
      }
      // Log other Prisma errors
      console.error('=== PRISMA ERROR ===');
      console.error('Error code:', error?.code);
      console.error('Error message:', error?.message);
      console.error('Full error:', error);
      // Re-throw other errors
      throw error;
    }
  }

  /**
   * Create double-entry transfer transactions (BANKA_KASA_TRANSFER or KASA_BANKA_TRANSFER)
   * Creates 2 linked transactions in a single DB transaction
   */
  private async createTransferTransaction(
    data: CreateTransactionDto,
    createdBy: string,
    createdByEmail: string
  ): Promise<TransactionDto> {
    try {
      console.log('=== CREATE TRANSFER TRANSACTION ===');
      console.log('Input data:', JSON.stringify(data, null, 2));
      console.log('Created by:', createdBy);

      if (!data.bankId) {
        throw new Error('Bank ID is required for transfer transactions');
      }

      // Verify bank exists
      const bank = await prisma.bank.findUnique({
        where: { id: data.bankId },
        select: { id: true, name: true, deletedAt: true },
      });
      if (!bank || bank.deletedAt) {
        throw new Error(`Bank with ID ${data.bankId} not found or deleted`);
      }

      // Generate transfer group ID to link the two transactions
      const transferGroupId = `transfer-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
      
      // BELGE NO (ZORUNLU) - 3.2: Transferlerde aynı belgeNo kökü, IN/OUT satırları suffix ile ayrılabilir
      const baseDocumentNo = await generateTransferDocumentNo(
        data.isoDate,
        data.documentNo,
        undefined // Base documentNo without suffix
      );
      
      const amount = data.incoming || data.outgoing || 0;
      if (amount <= 0) {
        throw new Error('Transfer amount must be greater than 0');
      }

      console.log('Transfer details:', { transferGroupId, amount, bankId: data.bankId, type: data.type, baseDocumentNo });

      // Use Prisma transaction to ensure both records are created atomically
      const result = await prisma.$transaction(async (tx) => {
      // TÜR / AÇIKLAMA / KATEGORİ AYRIMI - 4.1: Tür, satırın perspektifini anlatmalı
      // BANKA_KASA_TRANSFER: Bankadan kasaya transfer
      const isBankaKasaTransfer = 
        data.type === 'BANKA_KASA_TRANSFER_OUT' ||
        data.type === 'BANKA_KASA_TRANSFER_IN';
      
      if (isBankaKasaTransfer) {
        // 1. Bank row: source=BANKA, bankDelta=-amount (bank decreases)
        if (!data.bankId) {
          throw new Error('BANKA_KASA_TRANSFER requires bankId');
        }
        const bankBalanceAfter = await this.calculateBankBalanceAfter(
          data.isoDate,
          -amount,
          data.bankId,
          undefined
        );

        // Build bank row data
        // TRANSACTION KANONİK SÖZLEŞMESİ - 1.2: Transfer (Banka → Kasa)
        // BANKA satırı: bankDelta = -amount, incoming = 0, outgoing = 0
        // BELGE NO (ZORUNLU) - 3.2: Aynı belgeNo kökü, OUT suffix ile ayrılır
        const bankRowData: any = {
          isoDate: data.isoDate,
          documentNo: `${baseDocumentNo}-OUT`, // OUT suffix for bank row
          type: 'BANKA_KASA_TRANSFER_OUT', // TÜR AYRIMI - 4.1: Banka satırı için OUT type
          source: 'BANKA',
          counterparty: data.counterparty ?? null,
          description: data.description ?? `Banka → Kasa Transfer`,
          category: data.category ?? null,
          incoming: 0, // BANKA source: incoming ASLA kullanılmaz
          outgoing: 0, // BANKA source: outgoing ASLA kullanılmaz
          bankDelta: -amount, // BANKA source: SADECE bankDelta kullanılır
          displayIncoming: null,
          displayOutgoing: null,
          balanceAfter: 0, // Bank transactions don't affect cash balance
          cashAccountId: data.cashAccountId ?? null,
          bankId: data.bankId,
          creditCardId: null,
          chequeId: null,
          customerId: null,
          supplierId: null,
          attachmentId: null,
          loanInstallmentId: null,
          transferGroupId: transferGroupId, // Links related transfer transactions
          createdBy, // KULLANICI / AUTH / AUDIT - 7.1: createdByUserId
          createdByEmail, // KULLANICI / AUTH / AUDIT - 7.1: createdByEmail
        };

        const bankRow = await tx.transaction.create({
          data: bankRowData,
        });

        // 2. Cash row: source=KASA, incoming=amount (cash increases)
        // Calculate balance using tx client to ensure consistency within transaction
        const cashBalanceAfter = await this.calculateBalanceAfterWithTx(
          tx,
          data.isoDate,
          amount,
          0,
          'KASA',
          undefined,
          data.cashAccountId ?? null
        );

        // Build cash row data
        // TRANSACTION KANONİK SÖZLEŞMESİ - 1.2: Transfer (Banka → Kasa)
        // KASA satırı: incoming = amount, outgoing = 0, bankDelta = 0
        // İki satır: transferGroupId ile bağlanır, aynı belgeNo kökünü paylaşır
        // BELGE NO (ZORUNLU) - 3.2: Aynı belgeNo kökü, IN suffix ile ayrılır
        const cashRowData: any = {
          isoDate: data.isoDate,
          documentNo: `${baseDocumentNo}-IN`, // IN suffix for cash row
          type: 'BANKA_KASA_TRANSFER_IN', // TÜR AYRIMI - 4.1: Kasa satırı için IN type
          source: 'KASA',
          counterparty: data.counterparty ?? null,
          description: data.description ?? `Banka → Kasa Transfer`,
          category: data.category ?? null,
          incoming: amount, // KASA source: incoming/outgoing kullanılır
          outgoing: 0,
          bankDelta: 0, // KASA source: bankDelta ASLA kullanılmaz
          displayIncoming: null,
          displayOutgoing: null,
          balanceAfter: cashBalanceAfter,
          cashAccountId: data.cashAccountId ?? null,
          bankId: null, // Cash row doesn't have bankId
          creditCardId: null,
          chequeId: null,
          customerId: null,
          supplierId: null,
          attachmentId: null,
          loanInstallmentId: null,
          transferGroupId: transferGroupId, // Links related transfer transactions
          createdBy, // KULLANICI / AUTH / AUDIT - 7.1: createdByUserId
          createdByEmail, // KULLANICI / AUTH / AUDIT - 7.1: createdByEmail
        };

        const cashRow = await tx.transaction.create({
          data: cashRowData,
        });

        // Return the cash row as the primary transaction (for frontend compatibility)
        return cashRow;
      } else {
        // TÜR / AÇIKLAMA / KATEGORİ AYRIMI - 4.1: Tür, satırın perspektifini anlatmalı
        // KASA_BANKA_TRANSFER: Kasadan bankaya transfer
        const isKasaBankaTransfer = 
          data.type === 'KASA_BANKA_TRANSFER_OUT' ||
          data.type === 'KASA_BANKA_TRANSFER_IN';
        
        if (isKasaBankaTransfer) {
        // 1. Cash row: source=KASA, outgoing=amount (cash decreases)
        // Calculate balance using tx client to ensure consistency within transaction
        const cashBalanceAfter = await this.calculateBalanceAfterWithTx(
          tx,
          data.isoDate,
          0,
          amount,
          'KASA',
          undefined,
          data.cashAccountId ?? null
        );

        // Build cash row data
        // TRANSACTION KANONİK SÖZLEŞMESİ - 1.2: Transfer (Kasa → Banka)
        // KASA satırı: outgoing = amount, incoming = 0, bankDelta = 0
        // BELGE NO (ZORUNLU) - 3.2: Aynı belgeNo kökü, OUT suffix ile ayrılır
        const cashRowData: any = {
          isoDate: data.isoDate,
          documentNo: `${baseDocumentNo}-OUT`, // OUT suffix for cash row (cash goes out)
          type: 'KASA_BANKA_TRANSFER_OUT', // TÜR AYRIMI - 4.1: Kasa satırı için OUT type
          source: 'KASA',
          counterparty: data.counterparty ?? null,
          description: data.description ?? `Kasa → Banka Transfer`,
          category: data.category ?? null,
          incoming: 0,
          outgoing: amount, // KASA source: incoming/outgoing kullanılır
          bankDelta: 0, // KASA source: bankDelta ASLA kullanılmaz
          displayIncoming: null,
          displayOutgoing: null,
          balanceAfter: cashBalanceAfter,
          cashAccountId: data.cashAccountId ?? null,
          bankId: null, // Cash row doesn't have bankId
          creditCardId: null,
          chequeId: null,
          customerId: null,
          supplierId: null,
          attachmentId: null,
          loanInstallmentId: null,
          transferGroupId: transferGroupId, // Links related transfer transactions
          createdBy, // KULLANICI / AUTH / AUDIT - 7.1: createdByUserId
          createdByEmail, // KULLANICI / AUTH / AUDIT - 7.1: createdByEmail
        };

        const cashRow = await tx.transaction.create({
          data: cashRowData,
        });

        // 2. Bank row: source=BANKA, bankDelta=+amount (bank increases)
        if (!data.bankId) {
          throw new Error('KASA_BANKA_TRANSFER requires bankId');
        }
        const bankBalanceAfter = await this.calculateBankBalanceAfter(
          data.isoDate,
          amount,
          data.bankId,
          undefined
        );

        // Build bank row data
        // TRANSACTION KANONİK SÖZLEŞMESİ - 1.2: Transfer (Kasa → Banka)
        // BANKA satırı: bankDelta = +amount, incoming = 0, outgoing = 0
        // İki satır: transferGroupId ile bağlanır, aynı belgeNo kökünü paylaşır
        // BELGE NO (ZORUNLU) - 3.2: Aynı belgeNo kökü, IN suffix ile ayrılır
        const bankRowData: any = {
          isoDate: data.isoDate,
          documentNo: `${baseDocumentNo}-IN`, // IN suffix for bank row (bank receives)
          type: 'KASA_BANKA_TRANSFER_IN', // TÜR AYRIMI - 4.1: Banka satırı için IN type
          source: 'BANKA',
          counterparty: data.counterparty ?? null,
          description: data.description ?? `Kasa → Banka Transfer`,
          category: data.category ?? null,
          incoming: 0, // BANKA source: incoming ASLA kullanılmaz
          outgoing: 0, // BANKA source: outgoing ASLA kullanılmaz
          bankDelta: amount, // BANKA source: SADECE bankDelta kullanılır
          displayIncoming: null,
          displayOutgoing: null,
          balanceAfter: 0, // Bank transactions don't affect cash balance
          cashAccountId: data.cashAccountId ?? null,
          bankId: data.bankId,
          creditCardId: null,
          chequeId: null,
          customerId: null,
          supplierId: null,
          attachmentId: null,
          loanInstallmentId: null,
          transferGroupId: transferGroupId, // Links related transfer transactions
          createdBy, // KULLANICI / AUTH / AUDIT - 7.1: createdByUserId
          createdByEmail, // KULLANICI / AUTH / AUDIT - 7.1: createdByEmail
        };

        const bankRow = await tx.transaction.create({
          data: bankRowData,
        });

          // Return the cash row as the primary transaction (for frontend compatibility)
          return cashRow;
        } else {
          throw new Error(`Invalid transfer type: ${data.type}`);
        }
      }
    });

      console.log('Transfer transaction created successfully:', result.id);
      return this.mapToDto(result);
    } catch (error: any) {
      console.error('=== CREATE TRANSFER TRANSACTION ERROR ===');
      console.error('Error type:', error?.constructor?.name);
      console.error('Error code:', error?.code);
      console.error('Error message:', error?.message);
      console.error('Error stack:', error?.stack);
      console.error('Error meta:', error?.meta);
      console.error('Full error:', JSON.stringify(error, Object.getOwnPropertyNames(error), 2));
      
      // Handle Prisma errors
      if (error?.code === 'P2003') {
        const field = error.meta?.field_name || 'foreign key';
        const errorMsg = `Invalid ${field}: The referenced record does not exist.`;
        console.error(errorMsg);
        throw new Error(errorMsg);
      }
      
      // Handle unknown field errors (migration not applied)
      if (error?.code === 'P2009' || error?.message?.includes('Unknown arg') || error?.message?.includes('transferGroupId') || error?.message?.includes('Unknown field')) {
        console.warn('transferGroupId field not found in schema, retrying without it...');
        // Retry without transferGroupId - remove it from data objects
        return this.createTransferTransactionWithoutGroupId(data, createdBy, createdByEmail);
      }
      
      // Re-throw with better error message
      if (error instanceof Error) {
        const errorMsg = `Failed to create transfer transaction: ${error.message}`;
        console.error(errorMsg);
        throw new Error(errorMsg);
      }
      const errorMsg = `Failed to create transfer transaction: ${String(error)}`;
      console.error(errorMsg);
      throw new Error(errorMsg);
    }
  }

  /**
   * Calculate balance after using Prisma transaction client (for use inside $transaction)
   */
  private async calculateBalanceAfterWithTx(
    tx: any,
    isoDate: string,
    incoming: number,
    outgoing: number,
    storedSource: string,
    excludeTransactionId?: string,
    cashAccountId?: string | null
  ): Promise<number> {
    const where: any = {
      deletedAt: null,
      isoDate: { lte: isoDate },
      source: 'KASA',
    };

    if (excludeTransactionId) {
      where.id = { not: excludeTransactionId };
    }

    if (cashAccountId) {
      where.cashAccountId = cashAccountId;
    }

    const transactions = await tx.transaction.findMany({
      where,
      select: {
        incoming: true,
        outgoing: true,
      },
      orderBy: [
        { isoDate: 'asc' },
        { createdAt: 'asc' },
      ],
    });

    let balance = 0;
    for (const txItem of transactions) {
      const cashDelta = Number(txItem.incoming) - Number(txItem.outgoing);
      balance += cashDelta;
    }

    if (storedSource === 'KASA') {
      const cashDelta = incoming - outgoing;
      balance += cashDelta;
    }

    return balance;
  }

  /**
   * Create transfer transaction without transferGroupId (fallback when migration not applied)
   */
  private async createTransferTransactionWithoutGroupId(
    data: CreateTransactionDto,
    createdBy: string,
    createdByEmail: string
  ): Promise<TransactionDto> {
    console.log('Creating transfer transaction without transferGroupId (migration not applied)');
    
    // BELGE NO (ZORUNLU) - 3.2: Transferlerde aynı belgeNo kökü, IN/OUT satırları suffix ile ayrılabilir
    const baseDocumentNo = await generateTransferDocumentNo(
      data.isoDate,
      data.documentNo,
      undefined // Base documentNo without suffix
    );
    
    const amount = data.incoming || data.outgoing || 0;
    
    const result = await prisma.$transaction(async (tx) => {
      const isBankaKasaTransfer = 
        data.type === 'BANKA_KASA_TRANSFER_OUT' ||
        data.type === 'BANKA_KASA_TRANSFER_IN';
      
      if (isBankaKasaTransfer) {
        // 1. Bank row
        // TRANSACTION KANONİK SÖZLEŞMESİ - 1.2: BANKA satırı: bankDelta = -amount, incoming = 0, outgoing = 0
        // BELGE NO (ZORUNLU) - 3.2: Aynı belgeNo kökü, OUT suffix ile ayrılır
        // TÜR AYRIMI - 4.1: Banka satırı için OUT type
        const bankRow = await tx.transaction.create({
          data: {
            isoDate: data.isoDate,
            documentNo: `${baseDocumentNo}-OUT`, // OUT suffix for bank row
            type: 'BANKA_KASA_TRANSFER_OUT',
            source: 'BANKA',
            counterparty: data.counterparty ?? null,
            description: data.description ?? `Banka → Kasa Transfer`,
            category: data.category ?? null,
            incoming: 0, // BANKA source: incoming ASLA kullanılmaz
            outgoing: 0, // BANKA source: outgoing ASLA kullanılmaz
            bankDelta: -amount, // BANKA source: SADECE bankDelta kullanılır
            displayIncoming: null,
            displayOutgoing: null,
            balanceAfter: 0,
            cashAccountId: data.cashAccountId ?? null,
            bankId: data.bankId,
            creditCardId: null,
            chequeId: null,
            customerId: null,
            supplierId: null,
            attachmentId: null,
            loanInstallmentId: null,
            createdBy,
            createdByEmail,
          },
        });

        // 2. Cash row
        const cashBalanceAfter = await this.calculateBalanceAfterWithTx(
          tx,
          data.isoDate,
          amount,
          0,
          'KASA',
          undefined,
          data.cashAccountId ?? null
        );

        // 2. Cash row
        // TRANSACTION KANONİK SÖZLEŞMESİ - 1.2: KASA satırı: incoming = amount, outgoing = 0, bankDelta = 0
        // BELGE NO (ZORUNLU) - 3.2: Aynı belgeNo kökü, IN suffix ile ayrılır
        const cashRow = await tx.transaction.create({
          data: {
            isoDate: data.isoDate,
            documentNo: `${baseDocumentNo}-IN`, // IN suffix for cash row
            type: 'BANKA_KASA_TRANSFER_IN', // TÜR AYRIMI - 4.1: Kasa satırı için IN type
            source: 'KASA',
            counterparty: data.counterparty ?? null,
            description: data.description ?? `Banka → Kasa Transfer`,
            category: data.category ?? null,
            incoming: amount, // KASA source: incoming/outgoing kullanılır
            outgoing: 0,
            bankDelta: 0, // KASA source: bankDelta ASLA kullanılmaz
            displayIncoming: null,
            displayOutgoing: null,
            balanceAfter: cashBalanceAfter,
            cashAccountId: data.cashAccountId ?? null,
            bankId: null,
            creditCardId: null,
            chequeId: null,
            customerId: null,
            supplierId: null,
            attachmentId: null,
            loanInstallmentId: null,
            createdBy,
            createdByEmail,
          },
        });

        return cashRow;
      } else {
        const isKasaBankaTransfer = 
          data.type === 'KASA_BANKA_TRANSFER_OUT' ||
          data.type === 'KASA_BANKA_TRANSFER_IN';
        
        if (isKasaBankaTransfer) {
          // 1. Cash row
          const cashBalanceAfter = await this.calculateBalanceAfterWithTx(
            tx,
            data.isoDate,
            0,
            amount,
            'KASA',
            undefined,
            data.cashAccountId ?? null
          );

          // 1. Cash row
          // TRANSACTION KANONİK SÖZLEŞMESİ - 1.2: KASA satırı: outgoing = amount, incoming = 0, bankDelta = 0
          // BELGE NO (ZORUNLU) - 3.2: Aynı belgeNo kökü, OUT suffix ile ayrılır
          // TÜR AYRIMI - 4.1: Kasa satırı için OUT type
          const cashRow = await tx.transaction.create({
            data: {
              isoDate: data.isoDate,
              documentNo: `${baseDocumentNo}-OUT`, // OUT suffix for cash row (cash goes out)
              type: 'KASA_BANKA_TRANSFER_OUT',
              source: 'KASA',
              counterparty: data.counterparty ?? null,
              description: data.description ?? `Kasa → Banka Transfer`,
              category: data.category ?? null,
            incoming: 0,
            outgoing: amount, // KASA source: incoming/outgoing kullanılır
            bankDelta: 0, // KASA source: bankDelta ASLA kullanılmaz
            displayIncoming: null,
            displayOutgoing: null,
            balanceAfter: cashBalanceAfter,
            cashAccountId: data.cashAccountId ?? null,
            bankId: null,
            creditCardId: null,
            chequeId: null,
            customerId: null,
            supplierId: null,
            attachmentId: null,
            loanInstallmentId: null,
            createdBy,
            createdByEmail,
          },
        });

        // 2. Bank row
        // TRANSACTION KANONİK SÖZLEŞMESİ - 1.2: BANKA satırı: bankDelta = +amount, incoming = 0, outgoing = 0
        // BELGE NO (ZORUNLU) - 3.2: Aynı belgeNo kökü, IN suffix ile ayrılır
        const bankRow = await tx.transaction.create({
          data: {
            isoDate: data.isoDate,
            documentNo: `${baseDocumentNo}-IN`, // IN suffix for bank row (bank receives)
            type: 'KASA_BANKA_TRANSFER_IN', // TÜR AYRIMI - 4.1: Banka satırı için IN type
            source: 'BANKA',
            counterparty: data.counterparty ?? null,
            description: data.description ?? `Kasa → Banka Transfer`,
            category: data.category ?? null,
            incoming: 0, // BANKA source: incoming ASLA kullanılmaz
            outgoing: 0, // BANKA source: outgoing ASLA kullanılmaz
            bankDelta: amount, // BANKA source: SADECE bankDelta kullanılır
            displayIncoming: null,
            displayOutgoing: null,
            balanceAfter: 0,
            cashAccountId: data.cashAccountId ?? null,
            bankId: data.bankId,
            creditCardId: null,
            chequeId: null,
            customerId: null,
            supplierId: null,
            attachmentId: null,
            loanInstallmentId: null,
            createdBy,
            createdByEmail,
          },
        });

          return cashRow;
        } else {
          throw new Error(`Invalid transfer type: ${data.type}`);
        }
      }
    });

    return this.mapToDto(result);
  }

  /**
   * Calculate bank balance after a transaction (simplified - just for transfer tracking)
   * Note: Bank balance is calculated from openingBalance + sum(bankDelta) in reports
   */
  private async calculateBankBalanceAfter(
    isoDate: string,
    bankDelta: number,
    bankId: string,
    excludeTransactionId?: string
  ): Promise<number> {
    // This is a placeholder - actual bank balance calculation is done in reports
    // We return 0 here as bank transactions don't affect cash balance
    return 0;
  }

  /**
   * Update a transaction
   */
  async updateTransaction(
    id: string,
    data: UpdateTransactionDto,
    updatedBy: string
  ): Promise<TransactionDto> {
    const existing = await prisma.transaction.findUnique({
      where: { id },
    });

    if (!existing) {
      throw new Error('Transaction not found');
    }

    if (existing.deletedAt) {
      throw new Error('Cannot update deleted transaction');
    }

    // Recalculate balance if amounts changed
    // Use normalized values if source/type changed, otherwise use existing
    const incoming = data.incoming !== undefined ? data.incoming : Number(existing.incoming);
    const outgoing = data.outgoing !== undefined ? data.outgoing : Number(existing.outgoing);
    const isoDate = data.isoDate || existing.isoDate;
    // Use stored source from existing transaction (or normalized if type changed)
    const storedSource = data.source || existing.source;
    const cashAccountId = data.cashAccountId !== undefined ? data.cashAccountId : existing.cashAccountId;
    const balanceAfter = await calculateBalanceAfter(isoDate, incoming, outgoing, storedSource, id, cashAccountId);

    const updated = await prisma.transaction.update({
      where: { id },
      data: {
        ...data,
        incoming: data.incoming !== undefined ? data.incoming : existing.incoming,
        outgoing: data.outgoing !== undefined ? data.outgoing : existing.outgoing,
        bankDelta: data.bankDelta !== undefined ? data.bankDelta : existing.bankDelta,
        balanceAfter,
        updatedBy,
        updatedAt: new Date(),
      },
    });

    return this.mapToDto(updated);
  }

  /**
   * Get transaction by ID
   */
  async getTransactionById(id: string): Promise<TransactionDto | null> {
    const transaction = await prisma.transaction.findUnique({
      where: { id },
    });

    if (!transaction || transaction.deletedAt) {
      return null;
    }

    return this.mapToDto(transaction);
  }

  /**
   * List transactions with filters
   */
  async listTransactions(query: TransactionListQuery): Promise<TransactionListResponse> {
    // BUG 2 FIX: Exclude synthetic "Açılış bakiyesi" transactions from daily transaction list
    // These are created for bank opening balances but should not appear in "Gün içi işlemler"
    const descriptionFilter = {
      OR: [
        { description: null },
        { description: { not: 'Açılış bakiyesi' } },
      ],
    };

    const where: any = {
      deletedAt: null,
    };

    // Build AND array to combine description filter with search filter
    const andConditions: any[] = [descriptionFilter];

    if (query.from || query.to) {
      where.isoDate = {};
      if (query.from) {
        where.isoDate.gte = query.from;
      }
      if (query.to) {
        where.isoDate.lte = query.to;
      }
    }

    if (query.documentNo) {
      where.documentNo = { contains: query.documentNo, mode: 'insensitive' };
    }

    if (query.type) {
      where.type = query.type;
    }

    if (query.source) {
      where.source = query.source;
    }

    if (query.counterparty) {
      where.counterparty = { contains: query.counterparty, mode: 'insensitive' };
    }

    if (query.description) {
      where.description = { contains: query.description, mode: 'insensitive' };
    }

    if (query.bankId) {
      where.bankId = query.bankId;
    }

    if (query.creditCardId) {
      where.creditCardId = query.creditCardId;
    }

    if (query.createdBy) {
      where.createdBy = query.createdBy;
    }

    if (query.createdByEmail) {
      where.createdByEmail = { contains: query.createdByEmail, mode: 'insensitive' };
    }

    // If search is provided, add it to AND conditions
    if (query.search) {
      andConditions.push({
        OR: [
          { documentNo: { contains: query.search, mode: 'insensitive' } },
          { counterparty: { contains: query.search, mode: 'insensitive' } },
          { description: { contains: query.search, mode: 'insensitive' } },
        ],
      });
    }

    // Add AND conditions to where clause
    if (andConditions.length > 0) {
      where.AND = andConditions;
    }

    const page = query.page || 1;
    const pageSize = query.pageSize || 50;
    const skip = (page - 1) * pageSize;

    // Fix Bug 8: Default sort order is ascending by date (oldest to newest)
    const sortKey = query.sortKey || 'isoDate';
    const sortDir = query.sortDir || 'asc';
    
    // Build orderBy array based on sortKey
    const orderBy: any[] = [];
    if (sortKey === 'isoDate') {
      // For date sorting, use isoDate first, then createdAt as secondary sort
      orderBy.push({ isoDate: sortDir });
      orderBy.push({ createdAt: sortDir });
    } else {
      // For other fields, use the sortKey directly
      orderBy.push({ [sortKey]: sortDir });
      // Add isoDate as secondary sort for consistency
      orderBy.push({ isoDate: 'asc' });
    }

    const [transactions, totalCount] = await Promise.all([
      prisma.transaction.findMany({
        where,
        skip,
        take: pageSize,
        orderBy,
        include: {
          cheque: {
            select: {
              id: true,
              cekNo: true,
              drawerName: true,
              payeeName: true,
              issuerBankName: true,
            },
          },
          // NOTE: attachment relation not included - we only need attachmentId (already in transaction)
        },
      }),
      prisma.transaction.count({ where }),
    ]);

    // Calculate totals from ALL matching transactions (not just current page)
    const allTransactions = await prisma.transaction.findMany({
      where,
      select: {
        incoming: true,
        outgoing: true,
      },
    });

    const totalIncoming = allTransactions.reduce((sum: number, tx) => sum + Number(tx.incoming), 0);
    const totalOutgoing = allTransactions.reduce((sum: number, tx) => sum + Number(tx.outgoing), 0);

    return {
      items: transactions.map((tx) => this.mapToDto(tx)),
      totalCount,
      totalIncoming,
      totalOutgoing,
    };
  }

  /**
   * Soft delete a transaction
   */
  async deleteTransaction(id: string, deletedBy: string): Promise<void> {
    const transaction = await prisma.transaction.findUnique({
      where: { id },
    });

    if (!transaction) {
      throw new Error('Transaction not found');
    }

    if (transaction.deletedAt) {
      throw new Error('Transaction already deleted');
    }

    await prisma.transaction.update({
      where: { id },
      data: {
        deletedAt: new Date(),
        deletedBy,
      },
    });
  }

  /**
   * Map Prisma transaction to DTO
   */
  private mapToDto(transaction: any): TransactionDto {
    return {
      id: transaction.id,
      isoDate: transaction.isoDate,
      documentNo: transaction.documentNo,
      type: transaction.type,
      source: transaction.source,
      counterparty: transaction.counterparty,
      description: transaction.description,
      category: transaction.category,
      incoming: Number(transaction.incoming),
      outgoing: Number(transaction.outgoing),
      bankDelta: Number(transaction.bankDelta),
      displayIncoming: transaction.displayIncoming ? Number(transaction.displayIncoming) : null,
      displayOutgoing: transaction.displayOutgoing ? Number(transaction.displayOutgoing) : null,
      balanceAfter: Number(transaction.balanceAfter),
      cashAccountId: transaction.cashAccountId,
      bankId: transaction.bankId,
      creditCardId: transaction.creditCardId,
      chequeId: transaction.chequeId,
      customerId: transaction.customerId,
      supplierId: transaction.supplierId,
      attachmentId: transaction.attachmentId,
      loanInstallmentId: transaction.loanInstallmentId,
      transferGroupId: transaction.transferGroupId,
      createdAt: transaction.createdAt.toISOString(),
      createdBy: transaction.createdBy, // KULLANICI / AUTH / AUDIT - 7.1: createdByUserId
      createdByEmail: transaction.createdByEmail, // KULLANICI / AUTH / AUDIT - 7.1: createdByEmail
      updatedAt: transaction.updatedAt?.toISOString() || null,
      updatedBy: transaction.updatedBy || null,
      deletedAt: transaction.deletedAt?.toISOString() || null,
      deletedBy: transaction.deletedBy || null,
      // Include cheque information if available
      cheque: transaction.cheque
        ? {
            id: transaction.cheque.id,
            cekNo: transaction.cheque.cekNo,
            drawerName: transaction.cheque.drawerName,
            payeeName: transaction.cheque.payeeName,
            issuerBankName: transaction.cheque.issuerBankName,
          }
        : null,
      // NOTE: attachmentId is already included above (line 1087)
      // Frontend should fetch attachment via GET /api/attachments/:id when user clicks "Görüntüle"
    };
  }
}

